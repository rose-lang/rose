def dot(u: Rn, v: Rn): R = sum([for i < n, u_i * v_i])

def cross(u: R2, v: R2): R = u.x * v.y - v.x * u.y

# Return the signed distance from the origin to the convex
# counterclockwise-oriented polygon `p`.
def convexPolygonOriginSignedDistance(p: Rnx2): R =
  let segments = [for i < n,
    let p0 = p_i in
    let p1 = p_((i + 1) mod n) in
    let v = p1 - p0 in
    let a = dot(v, v) in

    # Consider the line through `p0` and `p1`. Call the vector from `p0` to the
    # origin (that is, `-p0`) "u". If we refer to the dot product of u and `v`
    # as `along`, then dividing that by `a` gives us a number that locates for
    # us the closest point to the origin on this line. If this number is between
    # zero and one, then the closest point lies on the line segment; otherwise,
    # it lies on the line but outside the segment between `p0` and `p1`. But
    # instead of dividing by `a`, we can just compare `along` to zero and `a` to
    # get the booleans `goodLeft` and `goodRight` directly.
    let along = -dot(p0, v) in

    {
      goodLeft = 0 <= along,
      goodRight = along < a,

      # distance from origin to `p0`
      fromStart = sqrt(dot(p0, p0)),

      # signed distance from origin using the half-plane defined by the directed
      # line from `p0` to `p1` (not the line segment)
      edgeSignedDist = cross(v, p0) / sqrt(a),
    }
  ] in

  # Since the polygon is convex, either the origin is inside the polygon (in
  # which case the closest point must be on an edge, not a vertex) or the
  # origin is outside the polygon. We compose the signed distance function as
  # the maximum of several components, taking one component for each edge; we
  # can think of these components as partial functions, where we set them to
  # negative infinity outside their "domain" since we're taking the maximum. So
  # for each edge, we include the region between the two lines perpendicular to
  # that edge passing through its two vertices (which is defined by the
  # half-plane SDF) and the region outside the polygon where the closest point
  # is the second endpoint of the edge. This particular choice of regions is
  # nice because it means that the only discontinuities in the computation of
  # the SDF are actual discontinuities in the form of its derivative.
  max([for i < n,
    let {goodLeft, goodRight, edgeSignedDist} = segments_i in
    let next = segments_((i + 1) mod n) in
    if goodLeft then (
      if goodRight then edgeSignedDist
      else if goodLeft then -infinity
      else next.fromStart
    ) else -infinity
  ])

type Line {start: R2, end: R2}

type Rectangle {x: R2, y: R2}

# Return the signed distance from the origin to the Minkowski sum of `rect` and
# the negative of `line` (that is, `start` and `end` points both multiplied by
# `-1`).
def rectLineDist(rect: Rectangle, line: Line): R =
  let tr = [rect.x_1, rect.y_1] in
  let tl = [rect.x_0, rect.y_1] in
  let bl = [rect.x_0, rect.y_0] in
  let br = [rect.x_1, rect.y_0] in

  let {start, end} = line in
  let flippedX = start.x > end.x in
  let flippedY = start.y > end.y in
  let [p, q] = if flippedX then [end, start] else [start, end] in

  convexPolygonOriginSignedDistance(
    if flippedX == flippedY then
      #   4 - 3
      #  /    |
      # 5     2
      # |    /
      # 0 - 1
      [bl - p, br - p, br - q, tr - q, tl - q, tl - p]
    else
      # 4 - 3
      # |    \
      # 5     2
      #  \    |
      #   0 - 1
      [bl - q, br - q, tr - q, tr - p, tl - p, bl - p]
  )
