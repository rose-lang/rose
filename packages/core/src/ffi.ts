import * as wasm from "@rose-lang/wasm";
import { Ty } from "@rose-lang/wasm/core/Ty";
import { Val } from "@rose-lang/wasm/interp/Val";

/**
 * Some of the types we expose in our API hold reference-counted pointers to
 * Rust objects living in WebAssembly memory. To avoid memory leaks, we use this
 * finalization registry to free those objects once they are no longer
 * referenced by any JavaScript objects. The `free` callback here typically
 * holds onto an instance of the class generated by `wasm-bindgen`, which means
 * that instance itself can't be used as the target for finalization (since that
 * strong reference would prevent garbage collection); thus, we wrap each of
 * these instances in a canonical object which is the one we actually register.
 * This does mean that if a user reaches in and pulls out the wrapped object, it
 * could become invalid if they don't hold onto the wrapper, so those inner
 * fields must be treated as private.
 */
const registry = new FinalizationRegistry((free: () => void) => {
  free();
});

/** Canonical wrapper for `rose_web::Func`. */
export interface Fn {
  f: wasm.Func;
}

export const bake = (ctx: wasm.Context, main: number): Fn => {
  const f = wasm.bake(ctx, main);
  const fn: Fn = { f };
  registry.register(fn, () => f.free());
  return fn;
};

export interface Body {
  /**
   * Unlike `Fn`, the `Context` type shouldn't be held onto in any public APIs,
   * so we don't give it a canonical wrapper; every instance must always be
   * `bake`d or `free`d.
   */
  ctx: wasm.Context;
  main: wasm.Block;
  arg: number;
  args: number[];
}

export const make = (
  generics: number,
  types: Ty[],
  params: Uint32Array,
  ret: number
): Body => {
  const x = wasm.make(generics, types, params, ret);
  try {
    return {
      ctx: x.ctx(),
      main: x.main(),
      arg: x.arg,
      args: Array.from(x.args()),
    };
  } finally {
    x.free();
  }
};

export const interp = (
  f: Fn,
  types: Ty[],
  generics: Uint32Array,
  arg: Val
): Val => wasm.interp(f.f, types, generics, arg);

export const derivative = (f: Fn): Fn => {
  const g = wasm.derivative(f.f);
  const fn: Fn = { f: g };
  registry.register(fn, () => g.free());
  return fn;
};

export { Block, Context } from "@rose-lang/wasm";
export type { Ty, Val };
