import * as wasm from "@rose-lang/wasm";
import { Type } from "@rose-lang/wasm/core/Type";
import { Val } from "@rose-lang/wasm/interp/Val";

/**
 * Some of the types we expose in our API hold reference-counted pointers to
 * Rust objects living in WebAssembly memory. To avoid memory leaks, we use this
 * finalization registry to free those objects once they are no longer
 * referenced by any JavaScript objects. The `free` callback here typically
 * holds onto an instance of the class generated by `wasm-bindgen`, which means
 * that instance itself can't be used as the target for finalization (since that
 * strong reference would prevent garbage collection); thus, we wrap each of
 * these instances in a canonical object which is the one we actually register.
 * This does mean that if a user reaches in and pulls out the wrapped object, it
 * could become invalid if they don't hold onto the wrapper, so those inner
 * fields must be treated as private.
 */
const registry = new FinalizationRegistry((free: () => void) => {
  free();
});

/** Canonical wrapper for `rose_web::Func`. */
export interface Fn {
  f: wasm.Func;
}

/**
 * Unlike `Fn`, the `Context` type shouldn't be held onto in any public APIs, so
 * we don't give it a canonical wrapper; every instance must always be `bake`d
 * or `free`d.
 */
export class Context extends wasm.Context {
  constructor(params: Type[], ret: Type) {
    super(params, ret);
  }

  set(t: Type): number {
    return super.set(t);
  }

  // for some reason errors happen when adding methods to this class that don't
  // already exist in `wasm.Context`; not sure why, but that's why `bake` is
  // just a function in this module instead of a method here
}

export const bake = (ctx: Context): Fn => {
  const f = wasm.bake(ctx);
  const fn: Fn = { f };
  registry.register(fn, () => f.free());
  return fn;
};

export const interp = (f: Fn, args: Val[]): Val => wasm.interp(f.f, args);

export const wasmExportName = wasm.wasmExportName();

export const compile = (f: Fn, generics: number[]) =>
  wasm.compile(f.f, new Uint32Array(generics));

export type { Type, Val };
