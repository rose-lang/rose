import * as wasm from "@rose-lang/wasm";
import { Type } from "@rose-lang/wasm/core/Type";
import { Val } from "@rose-lang/wasm/interp/Val";

/**
 * Some of the types we expose in our API hold reference-counted pointers to
 * Rust objects living in WebAssembly memory. To avoid memory leaks, we use this
 * finalization registry to free those objects once they are no longer
 * referenced by any JavaScript objects. The `free` callback here typically
 * holds onto an instance of the class generated by `wasm-bindgen`, which means
 * that instance itself can't be used as the target for finalization (since that
 * strong reference would prevent garbage collection); thus, we wrap each of
 * these instances in a canonical object which is the one we actually register.
 * This does mean that if a user reaches in and pulls out the wrapped object, it
 * could become invalid if they don't hold onto the wrapper, so those inner
 * fields must be treated as private.
 */
const registry = new FinalizationRegistry((free: () => void) => {
  free();
});

/** Canonical wrapper for `rose_web::Func`. */
export interface Fn {
  f: wasm.Func;
}

export const makeFunc = (
  params: Type[],
  locals: Type[],
  body: wasm.Body
): Fn => {
  const f = wasm.makeFunc(params, locals, body);
  const fn: Fn = { f };
  registry.register(fn, () => f.free());
  return fn;
};

export const interp = (f: Fn, args: Val[]): Val => wasm.interp(f.f, args);

// Unlike `Fn`, the `Body` type shouldn't be held onto in any public APIs, so we
// don't give it a canonical wrapper; every instance must always be consumed or
// otherwise `free`d.
export { Body } from "@rose-lang/wasm";
export type { Type, Val };
